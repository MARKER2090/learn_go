笔记 ：
for就是一个内存共享的，所以for循环里面，赋值某个数值都是最后一个数值；
可以理解为for遍历某个变量，都是放在一个桶里面；

后端工程师必备能力：
操作系统：
- 内存管理：将GO内存管理、linux内存管理融会贯通
- 文件系统：能够理解各种中间件为了优化IO的锁所采取的措施
计算机网络：TCP，学到你能理解linux上TCP所有的相关参数，以及如何调优的地步
数据库原理：搞懂MYSQL各个参数的含义，以及优化的方向 就可以了
计算机组成原理：看懂汇编，能够从计算机指令级别解释各种原子操作即可
分布式系统：
通信：怎么通信，RPC调用，HTTP调用等，通信出现的问题

计算中文个数：
println(utf8.RuneCountInString("你好"))
字符串处理：
使用strings包就可以了。

如果看到控制台上出现“CORS"就是代表着遇到了跨域问题了。
一般全部都是浏览器的拦截。
理解：
举例子：浏览器会对端口不同的情况拦截，然后询问我是否需要进行接收，也就是先询问我要不要。
我就是需要制定对应的通过规则，让浏览器知道（那些我制定的规则）是代表我要的。
跨域问题：
1. 协议不一样：http和https
2. 域名不一样：
3. 端口不一样：3000和8082

中间件：解决跨域问题
插件库网址：https://github.com/gin-gonic/contrib  
网站上有很多插件是可以解决各种跨域问题的，但是要注意有部分是有并发问题的。需要谨慎
https://github.com/gin-gonic/contrib/cors就是用来解决cors问题的

Service-Repostiory-DAO三层结构:
领域的界限也业务大小有关
service：代表domain service领域服务
repository：领域服务的存储
dao：代表的是数据库操作
domain：代表领域对象

调用流程：web（和http打交道）——>service(主要业务逻辑)——>repository（数据存储对象)——>dao(数据库操作)

docker相关知识：
docker compose up -d 后台启动
docker compose up 就是直接启动
如何访问docker的mysql？
在docker-desktop软件上，找到对应的mysql81-1,三个点那里，open in the terminal,进入命令行，输入
mysql -uroot -p，然后密码是root（通过docker-compose.yaml文件查看）
一进入后，需要输show databases;（注意分号）来查看数据库情况，然后输入
use smartbook;
select * from user;
就可以查看到存储的账号密码了。

BCrypt加密：号称最安全的加密算法
优点：
1.不需要自己生成盐值
2.不需要额外的存储盐值
3.可以通过控制cost来控制加密性能
4.同样的文本，加密的结果不同
需要用到golang.org/x/crypto

cookie的理解：
name:
value:
path:在那条路径下生效
domain:在哪里生效
expires:cookies什么时候过期
rawexpires:原始的数据
maxage:cookie最多保存多长时间
secure:bool，如果是true就只能是https访问(生产环境永远为true)
httponly:只在在浏览器访问的时候带上去，自己通过js脚本就访问不了(生产环境永远为true)
samesite:。。。
raw:...
unparsed:...

课件上的说明：
Domain: 也就是 Cookie 可以用在什么域名下，按照最小化原则来设定。
Path：Cookie 可以用在什么路径下，同样按照最小化原则来设定。
Max-Age 和 Expires：过期时间，只保留必要时间。
Http-Only：设置为 true 的话，那么浏览器上的 JS 代码将无法使用这个 Cookie。永远设置为 true。
Secure：只能用于 HTTPS 协议，生产环境永远设置为 true。
SameSite：是否允许跨站发送 Cookie，尽量避免。

cookie不安全所以不会存数据敏感的内容，都是存一些无关要紧的东西
session都是存放数据敏感的的内容
session插件：https://github.com/gin-contrib/sessions


==========================
K8S初认识：
k8s就是管理容器的，我们通过容器发布应用，如果发布得多了，就需要一个管理者，k8s就是了。
我们需要将应用打包成为一个可以在linux环境下运行的应用，然后通过docker命令来打包到容器中，通过k8s的deployment配置文件来告诉k8s的deployment来管理我们的已经打包好可运行的应用。
==========================
安装k8s
命令行输入以下内容：
cat <<EOF | sudo tee /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://pkgs.k8s.io/core:/stable:/v1.28/rpm/
enabled=1
gpgcheck=1
gpgkey=https://pkgs.k8s.io/core:/stable:/v1.28/rpm/repodata/repomd.xml.key
EOF

sudo yum install -y kubectl

==========================
然后就需要一个Dockerfile文件
文件内容如下：
# 基础镜像:fedora
FROM fedora

# 拷贝smartbook可执行文件（linux环境下的）到/app文件夹内，其实app文件夹不写死，也可以放在/user/local文件夹下的
COPY smartbook /app/smartbook
# 工作目录是/app
WORKDIR /app

# CMD是执行命令
# ENTRYPOINT是最佳实践
ENTRYPOINT ["/app/smartbook"]

==========================
如果逐个敲代码的话，可以使用make文件来进行脚本的构建（如果没有安装make，就需要sudo yum install make)
window环境下安装make比较麻烦！
makefile内容如下：(linux环境下)
.PHONY: docker
docker:
	@rm webook || true
	@go build -tags=k8s -o webook .
	@docker rmi -f deyen/smartbook:v0.0.1
	@docker build -t deyen/smartbook-live:v0.0.1 .

命令行解释：
.PHONY可以理解为名称的意思，如果是.PHONY: docker，在执行命令的时候就要写make docker;如果是.PHONY: AAA，在命令行里面就要写make AAA。(经过自己的验证，好像也不是那么一回事)
-tags 参数就是带有标签的意思;
makefile内容如下：(window环境下)
.PHONY: docker
docker:
	@rm webook || true
	@GOOS=linux GOARCH=arm go build -tags=k8s -o webook .
	@docker rmi -f deyen/smartbook:v0.0.1
	@docker build -t deyen/smartbook-live:v0.0.1 .

通过make docker来执行makefile文件

注意：如果重复构建的话，docker-desktop上的应用那个创建时间依然是之前开始构建的时间，如果对应用内代码进行了小改动，才会被docker-desktop认为是新的应用
==========================

启动kubernetes
将应用打包成docker的应用后，利用kubernetes进行部署，需要提前写好deployments.yaml文件
然后命令行输入kubectl apply -f k8s-smartbook-deployments.yaml
通过kubectl get deployments，查看自己已经启动的”运维“，也就是pods们的管理者deloyments
通过kubectl get pods，查看自己已经启动的pods容器（一个容器可以装很多个应用服务）
下面是实时代码显示：
[deyen@deyen smartbook]$ kubectl get pods
NAME                         READY   STATUS    RESTARTS   AGE
smartbook-5567f7bd6f-79kqc   1/1     Running   0          28s
smartbook-5567f7bd6f-8tlnj   1/1     Running   0          29s
smartbook-5567f7bd6f-bqwb2   1/1     Running   0          27s

看到2：33
